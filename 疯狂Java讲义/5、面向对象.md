
|概念|英文|解释|
|----|----|----|
|类|class|事物抽象|
|对象/实例|object/instance|具体存在|

```
qualifier class name{
	constructors
	member variables
	methods
}
```

|类|解释|
|----|----|
|修饰符|类的访问权限|
|构造器|构造类的实例|
|成员变量|实例的状态数据|
|方法|实例的行为特征或功能实现|


|类|解释|
|----|----|
|外部类||
|内部类||

|内部类|解释|
|----|----|
|匿名内部类||
|局部内部类||



|成员变量|解释|
|----|----|
|对象/实例/非静态变量|没有static修饰|
|类/静态变量|static修饰|


|全局变量|
|局部变量|
|临时变量|

|构造器|解释|
|----|----|
|||
```
修饰符 构造器名(形参列表){
	statement
}
```

|构造器与方法的区别|
|----|
|构造器名必须与类名相同|
|构造器不能定义包括void的返回值类型|

构造器的返回值是隐式的，总是返回当前类的实例，无需定义返回值类型，如果定义了返回值类型包括void，那么此时将不是构造器而是一个方法。
如果类中没有定义构造器，那么系统将默认提供一个无参构造器。


|方法|解释|
|----|----|
|对象/实例方法|没有static修饰|
|类/静态/非静态方法|static修饰|


|变量、方法、内部类访问权限修饰符|访问级别|同类|同包|不同包|
|----|----|----|----|----|----|
|public|公开|可访问|可访问|可访问|
|protected|受保护|可访问|可访问|不可访问(除了外部类的子类)|
|无修饰符|默认/缺省|可访问|可访问|不可访问|
|private|私有|可访问|不可访问|不可访问|




|类访问权限修饰符|访问级别|修饰外部类|修饰内部类|同类|同包|不同包|
|----|----|----|----|----|----|----|----|
|public|公开|能修饰|能修饰|可实例化|可实例化|可实例化|
|protected|受保护|不能修饰|能修饰|可实例化|可实例化|不可实例化(包括外部类的子类)|
|无修饰符|默认|能修饰|能修饰|可实例化|可实例化|不可实例化|
|private|私有|不能修饰|能修饰|可实例化|不可实例化|不可实例化|


在与父类不同包的子类中，如果通过子类对象访问和调用父类中由protected修饰的变量和方法，确实可以；但如果通过父类的对象访问和调用的话，则不可以访问protected修饰的变量和方法。

不同包的外部类的子类，可以访问protected修饰的变量、方法、内部类，但不能实例化protected修饰的内部类、外部类。

不同包的外部类的子类，不可以访问无修饰符的变量、方法、内部类，也不能实例无修饰符的内部类、外部类。
缺省访问权限修饰符的类只能由本包中的类访问，其他包中的类都不可以访问。



|static|
|----|
|不能修饰外部类，可以修饰内部类|
|如果没有用static修饰内部类，则只能new一个外部类实例。再通过外部实例创建内部类。|



static修饰的内部类在不同类中，可以使用外部类名.内部类名来实例化。
非static修饰的内部类在不同类中，可以使用外部类的实例名称.new 内部类名来实例化。



static的作用是用于区分成员变量、方法、内部类、初始化块到底属于类本身还是属于实例。
在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。

“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”
方便在没有创建对象的情况下来进行调用。被static关键字修饰的不需要创建对象去调用，直接根据类名就可以去访问。
　　这段话虽然只是说明了static方法的特殊之处，但是可以看出static关键字的基本作用，简而言之，一句话来描述就是：
　　方便在没有创建对象的情况下来进行调用（方法/变量）。
　　很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。
　　static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。



default不是修饰符，不能修饰类、成员变量、构造器、方法。
一个Java源文件里面不能有两个public修饰的外部类。

final和abstract只能出现其中之一。
private、protected、public、无修饰符只能出现其中之一。

|final||


匿名内部类：
创建匿名内部类的同时，也会创建一个对象。

```
new 类名或接口名(){
    重写方法;
};
```




static修饰符可以放在访问权限修饰符的前或后，一般是在后。



静态成员变量和非静态成员变量之间的区别：

A:所属不同
         静态成员变量属于类，所以也称为为类变量
         非静态成员变量属于对象，所以也称为实例/对象变量
B:内存中位置不同
         静态成员变量存储于方法区的静态区
         非静态成员变量存储于堆内存
C:内存出现时间不同
         静态成员变量随着类的加载而加载，随着类的消失而消失
         非静态成员变量随着对象的创建而存在，随着对象的消失而消失
D:调用不同
         静态成员变量可以通过类名调用，也可以通过对象调用
         非静态成员变量只能通过对象名调用



|类初始化的顺序|
|----|
|父类静态变量|
|父类静态代码块|
|子类静态变量|
|子类静态代码块|
|父类非静态变量|
|父类非静态代码块|
|父类构造函数|
|子类非静态变量|
|子类非静态代码块|
|子类构造函数









|new|
|----|
|创建类的实例，也就是创建对象|


|对象的使用|
|----|
|访问对象的成员变量|
|调用对象的方法|
|static修饰的成员变量和方法可以使用类来调用，也可以使用实例来调用。|
|非static修饰的成员变量和方法，只可以使用实例来调用。|



```java
Person person1 = new Person();
person1.name = "zhang";
person1.age = 18;

//引用变量person1和person2指向了同一个Person对象。
Person person2 = person1;
```


|this|
|----|
|在构造器中引用的是：该构造方法正在初始化的对象|
|在方法中引用的是：调用该方法的对象|
|Java类中允许对象的一个成员直接调用另一个成员，可以省略this前缀。|
|因为调用static方法的是类，this无法指向类，所以static修饰的方法中无法使用this，也就是静态成员无法直接访问非静态成员。|
|不建议使用类的实例调用static修饰的成员变量、方法，因为static修饰的成员属于类不属于类的实例。|


